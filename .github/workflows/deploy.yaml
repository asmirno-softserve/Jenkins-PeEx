name: Deploy to EKS with staging + prod

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      action:
        description: "Terraform action (apply or destroy)"
        required: true
        default: "apply"
        type: choice
        options:
          - apply
          - destroy
  pull_request:
    branches:
      - main

jobs:
  terraform:
    name: Provision infrastructure with Terraform
    runs-on: ubuntu-latest
    if: github.event_name != 'pull_request'
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Terraform Init
        run: terraform -chdir=terraform init -input=false

      - name: Terraform Apply or Destroy
        run: |
          if [ "${{ github.event.inputs.action }}" = "apply" ]; then
            terraform -chdir=terraform apply -auto-approve
          else
            terraform -chdir=terraform destroy -auto-approve
          fi        

  build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: terraform
    if: github.event.inputs.action == 'apply'
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Node.js for semantic-release
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install semantic-release
        run: |
          npm init -y
          npm install --save-dev semantic-release @semantic-release/git @semantic-release/github @semantic-release/changelog

      - name: Generate version
        id: version
        run: |
          npx semantic-release --dry-run
          VERSION=$(npx semantic-release --dry-run | grep -oP 'next release version is \K[0-9]+\.[0-9]+\.[0-9]+')
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Build Docker image
        run: |
          docker build -t peex-app:${{ steps.version.outputs.version }} ./java

  push:
    name: Push Docker Image to ECR
    runs-on: ubuntu-latest
    needs: build
    if: github.event.inputs.action == 'apply'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-central-1

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Tag & Push Docker image
        run: |
          docker tag peex-app:${{ needs.build.outputs.version }} \
            ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.eu-central-1.amazonaws.com/peex-app:${{ needs.build.outputs.version }}
          docker push ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.eu-central-1.amazonaws.com/peex-app:${{ needs.build.outputs.version }}

  deploy-staging:
    name: Deploy to EKS (staging)
    runs-on: ubuntu-latest
    needs: [terraform, push]
    if: github.event.inputs.action == 'apply'
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-central-1

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region eu-central-1 \
            --name peex-eks

      - name: Deploy manifests to staging
        run: |
          kubectl apply -f k8s/deployment.yaml -n staging
          kubectl apply -f k8s/service.yaml -n staging

      - name: Deploy to staging
        run: |
          kubectl set image deployment/peex-app peex-app=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.eu-central-1.amazonaws.com/peex-app:${{ github.sha }} -n staging
          kubectl rollout status deployment/peex-app -n staging
      
      - name: Get staging LB URL
        id: get-url
        run: |
          url=$(kubectl get svc peex-app -n staging -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          echo "url=http://$url" >> $GITHUB_OUTPUT

    outputs:
      staging_url: ${{ steps.get-url.outputs.url }}

  test-staging:
    name: Run acceptance tests (staging)
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    if: github.event.inputs.action == 'apply'
    steps:
      - name: Test staging app
        run: curl -f ${{ needs.deploy-staging.outputs.staging_url }}/health

  deploy-prod:
    name: Deploy to EKS (prod)
    runs-on: ubuntu-latest
    needs: [test-staging]
    if: github.event.inputs.action == 'apply'
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-central-1

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region eu-central-1 \
            --name peex-eks

      - name: Deploy manifests to prod
        run: |
          kubectl apply -f k8s/deployment.yaml -n production
          kubectl apply -f k8s/service.yaml -n production

      - name: Deploy to prod
        run: |
          kubectl set image deployment/peex-app peex-app=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.eu-central-1.amazonaws.com/peex-app:${{ github.sha }} -n production
          kubectl rollout status deployment/peex-app -n production

  notify:
    name: Send notification email
    runs-on: ubuntu-latest
    needs: [terraform, build, push, deploy-staging, test-staging, deploy-prod]  
    if: always()
    steps:
      - name: Send email notification
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          secure: true
          username: ${{ secrets.MAIL_USERNAME }}
          password: ${{ secrets.MAIL_PASSWORD }}
          subject: "CI/CD Pipeline result for ${{ github.repository }}"
          to: ${{ secrets.MAIL_USERNAME }}
          from: ${{ secrets.MAIL_USERNAME }}
          body: |
            Hello,

            The CI/CD pipeline has finished for:
            - Repository: ${{ github.repository }}
            - Branch: ${{ github.ref_name }}
            - Commit: ${{ github.sha }}

            Action: **${{ github.event.inputs.action }}**

            Results:
            - Terraform: ${{ needs.terraform.result }}
            - Build & Push: ${{ needs.build-and-push.result }}
            - Deploy Staging: ${{ needs.deploy-staging.result }}
            - Test Staging: ${{ needs.test-staging.result }}
            - Deploy Prod: ${{ needs.deploy-prod.result }}

  app-build:
    name: Build project
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Build with Maven
        run: mvn -B clean install
        working-directory: java    
      
      - name: Upload build output
        uses: actions/upload-artifact@v4
        with:
          name: java-classes
          path: java/target/classes

  sonarcloud:
    name: SonarCloud Code Analysis
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    needs: app-build
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/download-artifact@v4
        with:
          name: java-classes
          path: java/target/classes

      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@v2
        with:
          args: >
            -Dsonar.organization=asmirno-softserve
            -Dsonar.projectKey=asmirno-softserve_Jenkins-PeEx
            -Dsonar.java.binaries=java/target/classes
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
